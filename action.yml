name: 'GitStream CMR'
description: 'Public github action for GitStream continuous merge platform'

inputs:
  full_repository:
    description: 'Path of full Repository'
    required: true
  head_ref:
    description: 'Head Branch Ref to checkout to'
    required: true
  base_ref:
    description: 'Base Branch Ref to checkout to'
    required: true
  client_payload:
    description: 'The client payload'
    required: true
  installation_id:
    description: 'The github app installation id'
    required: false
  resolver_url:
    description: 'Resolver url to send results to'
    required: true
  resolver_token:
    description: 'Optional token for resolver'
    required: false

jobs:
  create-check-run:
    runs-on: ubuntu-latest
    steps:
    - name: Echo payload
      run: |
        echo "${{ inputs.client_payload }}"
      shell: bash
    - name: Create GitStream check
      uses: actions/github-script@v3
      id: create-check
      env:
        OWNER: ${{ fromJSON(fromJSON(inputs.client_payload)).owner }}
        REPO: ${{ fromJSON(fromJSON(inputs.client_payload)).repo }}
        REF: ${{ fromJSON(fromJSON(inputs.client_payload)).headSha }}
      with:
        script: |
          try {
            await github.checks.create({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              name: 'gitStream.cm',
              status: 'in_progress',
              head_sha: process.env.REF
            });
          } catch (err) {
            core.setFailed(`Request failed with error ${err}`);
          }
  rules-engine-run:
    runs-on: ubuntu-latest
    using: 'composite'
    steps:
      - name: Create GitStream folder
        id: create-gitstream-folder
        shell: bash
        run: |
          mkdir gitstream
      - name: Checkout head branch
        id: checkout-head-branch
        uses: actions/checkout@v2
        with:
          repository: ${{ inputs.full_repository }}
          ref: ${{ github.event.inputs.head_ref }}
          fetch-depth: 0
          path: 'gitstream/'
      - name: Create ref to all branches in Repo
        id: create-ref
        run: |
          cd gitstream
          git branch -r | grep -v '\->' | grep '${{ github.event.inputs.base_ref }}' | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | while read remote; do git branch --track "${remote#origin/}" "$remote"; done        
          git fetch --all
          git pull --all
        shell: bash
      - name: Run The Action
        id: run-rule-engine
        if: always()
        run: |
          docker pull gitstream/rules-engine:latest
          docker run -v $(pwd)/gitstream:/code -e HEAD_REF=${{ github.event.inputs.head_ref }} -e BASE_REF=${{ github.event.inputs.base_ref }} -e CLIENT_PAYLOAD=${{ github.event.inputs.client_payload }} -e RULES_RESOLVER_URL=${{ github.event.inputs.resolver_url }} -e RULES_RESOLVER_TOKEN=${{ github.event.inputs.resolver_token }} gitstream/rules-engine
        shell: bash
  update-check-run-on-fail:
    runs-on: ubuntu-latest
    steps:
      - name: Update GitStream check on error
      if: ${{ runs.rules-engine-run.outcome == 'failure' }}
      uses: actions/github-script@v3
      id: invoke-check
      env:
        OWNER: ${{ fromJSON(fromJSON(github.event.inputs.client_payload)).owner }}
        REPO: ${{ fromJSON(fromJSON(github.event.inputs.client_payload)).repo }}
        REF: ${{ fromJSON(fromJSON(github.event.inputs.client_payload)).headSha }}
      with:
        script: |
          try {
            const existing = await github.checks.listForRef({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              ref: process.env.REF,
              check_name: 'gitStream.cm',
              filter: 'latest'
            });
            core.info(`existing: ${JSON.stringify(existing)}`);
            core.info(`if: ${JSON.stringify(existing.data && existing.data.check_runs.length)}`);
            if(existing.data && existing.data.check_runs.length) {
              core.info(`im here`);
              const updated = await github.checks.update({
                owner: process.env.OWNER,
                repo: process.env.REPO,
                check_run_id: existing.data.check_runs[0].id,
                status: 'completed',
                conclusion: 'failure'
              });
              core.info(`and here`);
              core.info(`done: ${JSON.stringify(updated)}`);
            }
          } catch (err) {
            core.setFailed(`Request failed with error ${err}`);
          }